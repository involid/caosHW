## Problem 0

Программе передаются два аргумента: имя файла, и текстовая строка для поиска.

Необходимо найти все вхождения строки в бинарном файле, используя отображение на память с помощью системного вызова mmap.

На стандартный поток вывода вывести список всех позиций (с нуля) в файле, где втречаются строка.

## Problem 1
Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

```
struct Item {
  int value;
  uint32_t next_pointer;
};
```
Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Используйте отображение содержимого файла на память.


## Problem 2

Программе передаются три аргумента: имя файла, положительное целое число N - размер квадратной матрицы, и положительное число W - ширина клетки матицы в символах.

Необходимо в указанном файле сформировать текст, который содержит матрицу, состоящую из чисел от 1 до N2, таким образом, чтобы числа заполняли её по спирали, по часовой стрелке.

Числа должны быть выровнены по правой границе ячейки матрицы.

Используйте mmap для записи в файл.

Можно использовать функции форматного вывода для преобразования числа в строку.

### Examples
Input
```
./solution out.txt 5 5
```

Output in out.txt

```
    1    2    3    4    5
   16   17   18   19    6
   15   24   25   20    7
   14   23   22   21    8
   13   12   11   10    9
```

## Problem 3
Необходимо реализовать функциональность функций, аналогичных malloc и free, которые выделяют память в явно заданном swap-файле (файле подкачки), который существует на диске, и имеет некоторый фиксированный размер.

Реализуйте функции:
```
    extern void*
    my_malloc(size_t size);

    extern void
    my_free(void *ptr);
```
которые ведут аналогичным образом с malloc и free.
А также функции, которые вызываются один раз: в начале работы программы, и в конце:

```
    extern void
    myalloc_initialize(int fd /* открытый на R/W файловый дескриптор существующего файла */);

    extern void
    myalloc_finalize();
```
Используйте стратегию наиболее экономичного расхода памяти в файле подкачки.
