## Problem 0
 Реализуйте функцию с прототипом:
```
#include <stdint.h>

extern void sum(ITYPE first, ITYPE second, ITYPE *res, int *CF);
``` 
в которой ITYPE - это произвольный беззнаковый целочисленный тип данных с неизвестной разрядностью.

Функция должна вычислить сумму значений first и second, результат записать по указателю в выходной параметр res. При возникновении целочисленного переполнения необходимо в выходной параметр CF записать значение 1, в противном случае - значение 0.

Используйте побитовые операции для вычислений. Операции сложения и вычитания допускаются только применительно к переменным цикла.

На сервер необходимо отправить исходный файл, содержащий только реализацию требуемой функции. Для успешной компиляции и тестирования можно использовать следующий ключ компиляции, задающий требуемый тип: -DITYPE=uint64_t.

## Problem 1
 Реализуйте функцию с прототипом:
```
#include <stdint.h>

extern void mul(ITYPE first, ITYPE second, ITYPE *res, int *CF);
``` 
в которой ITYPE - это произвольный беззнаковый целочисленный тип данных с неизвестной разрядностью.

Функция должна вычислить произведение значений first и second, результат записать по указателю в выходной параметр res. При возникновении целочисленного переполнения необходимо в выходной параметр CF записать значение 1, в противном случае - значение 0. В случае переполнения результат умножения считается не определенным, то есть его значение может быть любым.

Используйте побитовые операции для вычислений. Операции сложения и вычитания допускаются только применительно к переменным цикла.

На сервер необходимо отправить исходный файл, содержащий только реализацию требуемой функции. Для успешной компиляции и тестирования можно использовать следующий ключ компиляции, задающий требуемый тип: -DITYPE=uint64_t.

## Problem 2
 Реализуйте функцию с прототипом:
```
typedef enum {
    PlusZero      = 0x00,
    MinusZero     = 0x01,
    PlusInf       = 0xF0,
    MinusInf      = 0xF1,
    PlusRegular   = 0x10,
    MinusRegular  = 0x11,
    PlusDenormal  = 0x20,
    MinusDenormal = 0x21,
    SignalingNaN  = 0x30,
    QuietNaN      = 0x31
} float_class_t;

extern float_class_t
classify(double *value_ptr);
```      
которая классифицирует специальные значения вещественного числа, на которое указывает value_ptr, в соответствии со стандартом IEEE 754.

При решении допускается использовать только побитовые операции, включая сдвиги.

## problem 3
 Реализуйте калькулятор выражений над множествами в обратной польской записи.

На стандартном потоке ввода задается последовательность, состоящая из символов-значений, и символов-операций.

Значениями являются цифры от 0 до 9, и буквы английского алфавита (заглавные и строчные). Последовательности значений кодируют множества из 62 элементов.

Операциями являются:

* & - пересечение множеств;
* | - объединение множеств;
* ^ - симметрическая разность;
* ~ - дополнение текущего результата до полного множества.

В начальный момент времени, множество-результат является пустым. При чтении символов со стандартного потока ввода, когда встречается символ операции, то эта операция применяется к множеству-результату и последнему прочитанному множеству (как в обратной польской записи).

Вывести на экран полученное итоговое значение множества в нормализованной форме: сначала цифры, затем заглавные буквы, потом - строчные (упорядоченные по алфавиту).

Для хранения множеств использовать, суммарно, не более 16 байт памяти.

## Problem 4
 На стандартном потоке ввода подается последовательность символов в кодировке UTF-8.

Посчитать количество символов, которые могут быть представлены в кодирове ASCII, и количество символов, которые не могут быть представлены в этой кодировке.

На стандартный поток вывода вывести последовательно два эти числа.

В случае ошибки декодирования потока данных, необходимо вывести результаты подсчёта, полученные на момент обнаружения ошибки, и завершить работу программы с кодом ошибки 1.

Запрещается использовать какие-либо функции стандартной библиотеки, за исключением функций ввода. Используйте только битовые операции.

Не забывайте о том, что символ перевода строки \n является легальным ASCII-символом.

